/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package azuremarketplace.saas.implementation;

import azuremarketplace.saas.SaaSFulfillment;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import azuremarketplace.saas.models.Error;
import azuremarketplace.saas.models.OperationType;
import azuremarketplace.saas.models.PlansResponse;
import azuremarketplace.saas.models.Subscription;
import azuremarketplace.saas.models.SubscriptionsResponse;
import azuremarketplace.saas.models.SubscriptionSummary;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the SaaSFulfillment class.
 */
public class SaaSFulfillmentImpl extends ServiceClient implements SaaSFulfillment {
    /**
     * The Retrofit service to perform REST calls.
     */
    private SaaSFulfillmentService service;

    /**
     * Initializes an instance of SaaSFulfillment client.
     */
    public SaaSFulfillmentImpl() {
        this("https://marketplaceapi.microsoft.com/api/saas/subscriptions");
    }

    /**
     * Initializes an instance of SaaSFulfillment client.
     *
     * @param baseUrl the base URL of the host
     */
    public SaaSFulfillmentImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of SaaSFulfillment client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public SaaSFulfillmentImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https://marketplaceapi.microsoft.com/api/saas/subscriptions", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of SaaSFulfillment client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public SaaSFulfillmentImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of SaaSFulfillment client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public SaaSFulfillmentImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(SaaSFulfillmentService.class);
    }

    /**
     * The interface defining all the services for SaaSFulfillment to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SaaSFulfillmentService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment getAllOperations" })
        @GET("")
        Observable<Response<ResponseBody>> getAllOperations(@Query("api-version") String apiVersion, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment resolve" })
        @POST("resolve")
        Observable<Response<ResponseBody>> resolve(@Query("api-version") String apiVersion, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid, @Header("x-ms-marketplace-token") String xMsMarketplaceToken);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment getSubscription" })
        @GET("{subscriptionId}")
        Observable<Response<ResponseBody>> getSubscription(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment updateSubscription" })
        @PATCH("{subscriptionId}")
        Observable<Response<ResponseBody>> updateSubscription(@Path("subscriptionId") UUID subscriptionId, @Body Object body, @Query("ApiVersion") String apiVersion3, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment deleteSubscription" })
        @HTTP(path = "{subscriptionId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSubscription(@Path("subscriptionId") UUID subscriptionId, @Query("ApiVersion") String apiVersion3, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment listSubscriptionPlans" })
        @GET("{subscriptionId}/listAvailablePlans")
        Observable<Response<ResponseBody>> listSubscriptionPlans(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment activateSubscription" })
        @POST("{subscriptionId}/activate")
        Observable<Response<ResponseBody>> activateSubscription(@Path("subscriptionId") UUID subscriptionId, @Body Object body, @Query("api-version") String apiVersion, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment getSubscriptionOperations" })
        @GET("{subscriptionId}/operations")
        Observable<Response<ResponseBody>> getSubscriptionOperations(@Path("subscriptionId") UUID subscriptionId, @Query("api-version") String apiVersion, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment getSubscriptionOperation" })
        @GET("{subscriptionId}/operations/{operationId}")
        Observable<Response<ResponseBody>> getSubscriptionOperation(@Path("subscriptionId") UUID subscriptionId, @Path("operationId") UUID operationId, @Query("api-version") String apiVersion, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: azuremarketplace.saas.SaaSFulfillment updateOperation" })
        @PATCH("{subscriptionId}/operations/{operationId}")
        Observable<Response<ResponseBody>> updateOperation(@Path("subscriptionId") UUID subscriptionId, @Path("operationId") UUID operationId, @Body Object body, @Query("ApiVersion") String apiVersion3, @Header("Content-Type") String contentType, @Header("x-ms-requestid") UUID xMsRequestid, @Header("x-ms-correlationid") UUID xMsCorrelationid);

    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllOperations() {
        return getAllOperationsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllOperationsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getAllOperationsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllOperationsAsync() {
        return getAllOperationsWithServiceResponseAsync().map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getAllOperationsWithServiceResponseAsync() {
        final String apiVersion = "2.0.0";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.getAllOperations(apiVersion, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getAllOperationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllOperations(UUID xMsRequestid, UUID xMsCorrelationid) {
        return getAllOperationsWithServiceResponseAsync(xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllOperationsAsync(UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getAllOperationsWithServiceResponseAsync(xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllOperationsAsync(UUID xMsRequestid, UUID xMsCorrelationid) {
        return getAllOperationsWithServiceResponseAsync(xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getAllOperationsWithServiceResponseAsync(UUID xMsRequestid, UUID xMsCorrelationid) {
        final String apiVersion = "2.0.0";
        return service.getAllOperations(apiVersion, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getAllOperationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getAllOperationsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SubscriptionsResponse>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object resolve() {
        return resolveWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> resolveAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(resolveWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> resolveAsync() {
        return resolveWithServiceResponseAsync().map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resolveWithServiceResponseAsync() {
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        final String xMsMarketplaceToken = null;
        return service.resolve(apiVersion, contentType, xMsRequestid, xMsCorrelationid, xMsMarketplaceToken)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resolveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object resolve(UUID xMsRequestid, UUID xMsCorrelationid, String xMsMarketplaceToken) {
        return resolveWithServiceResponseAsync(xMsRequestid, xMsCorrelationid, xMsMarketplaceToken).toBlocking().single().body();
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> resolveAsync(UUID xMsRequestid, UUID xMsCorrelationid, String xMsMarketplaceToken, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(resolveWithServiceResponseAsync(xMsRequestid, xMsCorrelationid, xMsMarketplaceToken), serviceCallback);
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> resolveAsync(UUID xMsRequestid, UUID xMsCorrelationid, String xMsMarketplaceToken) {
        return resolveWithServiceResponseAsync(xMsRequestid, xMsCorrelationid, xMsMarketplaceToken).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Resolve a subscription.
     * The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is redirected to a partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The response contains the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid for one hour only.
     *
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsMarketplaceToken The token query parameter in the URL when the user is redirected to the SaaS partner's website from Azure (for example,  https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser before using it.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> resolveWithServiceResponseAsync(UUID xMsRequestid, UUID xMsCorrelationid, String xMsMarketplaceToken) {
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        return service.resolve(apiVersion, contentType, xMsRequestid, xMsCorrelationid, xMsMarketplaceToken)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = resolveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> resolveDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SubscriptionSummary>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSubscription(UUID subscriptionId) {
        return getSubscriptionWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSubscriptionAsync(UUID subscriptionId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSubscriptionAsync(UUID subscriptionId) {
        return getSubscriptionWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSubscriptionWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.getSubscription(subscriptionId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSubscription(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return getSubscriptionWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSubscriptionAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSubscriptionAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return getSubscriptionWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * List subscriptions.
     * Lists all the SaaS subscriptions for a publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSubscriptionWithServiceResponseAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        return service.getSubscription(subscriptionId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSubscriptionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Subscription>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Error object if successful.
     */
    public Error updateSubscription(Object body, UUID subscriptionId, String apiVersion) {
        return updateSubscriptionWithServiceResponseAsync(body, subscriptionId, apiVersion).toBlocking().single().body();
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Error> updateSubscriptionAsync(Object body, UUID subscriptionId, String apiVersion, final ServiceCallback<Error> serviceCallback) {
        return ServiceFuture.fromResponse(updateSubscriptionWithServiceResponseAsync(body, subscriptionId, apiVersion), serviceCallback);
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<Error> updateSubscriptionAsync(Object body, UUID subscriptionId, String apiVersion) {
        return updateSubscriptionWithServiceResponseAsync(body, subscriptionId, apiVersion).map(new Func1<ServiceResponse<Error>, Error>() {
            @Override
            public Error call(ServiceResponse<Error> response) {
                return response.body();
            }
        });
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<ServiceResponse<Error>> updateSubscriptionWithServiceResponseAsync(Object body, UUID subscriptionId, String apiVersion) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (apiVersion == null) {
            throw new IllegalArgumentException("Parameter apiVersion is required and cannot be null.");
        }
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.updateSubscription(subscriptionId, body, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Error>>>() {
                @Override
                public Observable<ServiceResponse<Error>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Error> clientResponse = updateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Error object if successful.
     */
    public Error updateSubscription(Object body, UUID subscriptionId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        return updateSubscriptionWithServiceResponseAsync(body, subscriptionId, apiVersion, xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Error> updateSubscriptionAsync(Object body, UUID subscriptionId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Error> serviceCallback) {
        return ServiceFuture.fromResponse(updateSubscriptionWithServiceResponseAsync(body, subscriptionId, apiVersion, xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<Error> updateSubscriptionAsync(Object body, UUID subscriptionId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        return updateSubscriptionWithServiceResponseAsync(body, subscriptionId, apiVersion, xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Error>, Error>() {
            @Override
            public Error call(ServiceResponse<Error> response) {
                return response.body();
            }
        });
    }

    /**
     * Patch a subscription.
     * Use this call to update the plan, the user count (quantity), or both.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<ServiceResponse<Error>> updateSubscriptionWithServiceResponseAsync(Object body, UUID subscriptionId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (apiVersion == null) {
            throw new IllegalArgumentException("Parameter apiVersion is required and cannot be null.");
        }
        final String contentType = "application/json";
        return service.updateSubscription(subscriptionId, body, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Error>>>() {
                @Override
                public Observable<ServiceResponse<Error>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Error> clientResponse = updateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Error> updateSubscriptionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Error, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Error object if successful.
     */
    public Error deleteSubscription(UUID subscriptionId, String apiVersion) {
        return deleteSubscriptionWithServiceResponseAsync(subscriptionId, apiVersion).toBlocking().single().body();
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Error> deleteSubscriptionAsync(UUID subscriptionId, String apiVersion, final ServiceCallback<Error> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSubscriptionWithServiceResponseAsync(subscriptionId, apiVersion), serviceCallback);
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<Error> deleteSubscriptionAsync(UUID subscriptionId, String apiVersion) {
        return deleteSubscriptionWithServiceResponseAsync(subscriptionId, apiVersion).map(new Func1<ServiceResponse<Error>, Error>() {
            @Override
            public Error call(ServiceResponse<Error> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<ServiceResponse<Error>> deleteSubscriptionWithServiceResponseAsync(UUID subscriptionId, String apiVersion) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (apiVersion == null) {
            throw new IllegalArgumentException("Parameter apiVersion is required and cannot be null.");
        }
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.deleteSubscription(subscriptionId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Error>>>() {
                @Override
                public Observable<ServiceResponse<Error>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Error> clientResponse = deleteSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Error object if successful.
     */
    public Error deleteSubscription(UUID subscriptionId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        return deleteSubscriptionWithServiceResponseAsync(subscriptionId, apiVersion, xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Error> deleteSubscriptionAsync(UUID subscriptionId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Error> serviceCallback) {
        return ServiceFuture.fromResponse(deleteSubscriptionWithServiceResponseAsync(subscriptionId, apiVersion, xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<Error> deleteSubscriptionAsync(UUID subscriptionId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        return deleteSubscriptionWithServiceResponseAsync(subscriptionId, apiVersion, xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Error>, Error>() {
            @Override
            public Error call(ServiceResponse<Error> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a subscription.
     * Unsubscribe and delete the specified subscription.
     *
     * @param subscriptionId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<ServiceResponse<Error>> deleteSubscriptionWithServiceResponseAsync(UUID subscriptionId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (apiVersion == null) {
            throw new IllegalArgumentException("Parameter apiVersion is required and cannot be null.");
        }
        final String contentType = "application/json";
        return service.deleteSubscription(subscriptionId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Error>>>() {
                @Override
                public Observable<ServiceResponse<Error>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Error> clientResponse = deleteSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Error> deleteSubscriptionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Error, RestException>newInstance(this.serializerAdapter())
                .register(202, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object listSubscriptionPlans(UUID subscriptionId) {
        return listSubscriptionPlansWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> listSubscriptionPlansAsync(UUID subscriptionId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(listSubscriptionPlansWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> listSubscriptionPlansAsync(UUID subscriptionId) {
        return listSubscriptionPlansWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSubscriptionPlansWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.listSubscriptionPlans(subscriptionId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSubscriptionPlansDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object listSubscriptionPlans(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return listSubscriptionPlansWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> listSubscriptionPlansAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(listSubscriptionPlansWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> listSubscriptionPlansAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return listSubscriptionPlansWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * List available plans.
     * Use this call to find out if there are any private or public offers for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSubscriptionPlansWithServiceResponseAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        return service.listSubscriptionPlans(subscriptionId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSubscriptionPlansDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listSubscriptionPlansDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PlansResponse>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Error object if successful.
     */
    public Error activateSubscription(Object body, UUID subscriptionId) {
        return activateSubscriptionWithServiceResponseAsync(body, subscriptionId).toBlocking().single().body();
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Error> activateSubscriptionAsync(Object body, UUID subscriptionId, final ServiceCallback<Error> serviceCallback) {
        return ServiceFuture.fromResponse(activateSubscriptionWithServiceResponseAsync(body, subscriptionId), serviceCallback);
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<Error> activateSubscriptionAsync(Object body, UUID subscriptionId) {
        return activateSubscriptionWithServiceResponseAsync(body, subscriptionId).map(new Func1<ServiceResponse<Error>, Error>() {
            @Override
            public Error call(ServiceResponse<Error> response) {
                return response.body();
            }
        });
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<ServiceResponse<Error>> activateSubscriptionWithServiceResponseAsync(Object body, UUID subscriptionId) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.activateSubscription(subscriptionId, body, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Error>>>() {
                @Override
                public Observable<ServiceResponse<Error>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Error> clientResponse = activateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Error object if successful.
     */
    public Error activateSubscription(Object body, UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return activateSubscriptionWithServiceResponseAsync(body, subscriptionId, xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Error> activateSubscriptionAsync(Object body, UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Error> serviceCallback) {
        return ServiceFuture.fromResponse(activateSubscriptionWithServiceResponseAsync(body, subscriptionId, xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<Error> activateSubscriptionAsync(Object body, UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return activateSubscriptionWithServiceResponseAsync(body, subscriptionId, xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Error>, Error>() {
            @Override
            public Error call(ServiceResponse<Error> response) {
                return response.body();
            }
        });
    }

    /**
     * Activate a subscription.
     * Use this call to activate a subscription.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<ServiceResponse<Error>> activateSubscriptionWithServiceResponseAsync(Object body, UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        return service.activateSubscription(subscriptionId, body, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Error>>>() {
                @Override
                public Observable<ServiceResponse<Error>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Error> clientResponse = activateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Error> activateSubscriptionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Error, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSubscriptionOperations(UUID subscriptionId) {
        return getSubscriptionOperationsWithServiceResponseAsync(subscriptionId).toBlocking().single().body();
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSubscriptionOperationsAsync(UUID subscriptionId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionOperationsWithServiceResponseAsync(subscriptionId), serviceCallback);
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSubscriptionOperationsAsync(UUID subscriptionId) {
        return getSubscriptionOperationsWithServiceResponseAsync(subscriptionId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSubscriptionOperationsWithServiceResponseAsync(UUID subscriptionId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.getSubscriptionOperations(subscriptionId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSubscriptionOperationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSubscriptionOperations(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return getSubscriptionOperationsWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSubscriptionOperationsAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionOperationsWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSubscriptionOperationsAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return getSubscriptionOperationsWithServiceResponseAsync(subscriptionId, xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * List outstanding operations.
     * Lists the outstanding operations for the current publisher.
     *
     * @param subscriptionId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSubscriptionOperationsWithServiceResponseAsync(UUID subscriptionId, UUID xMsRequestid, UUID xMsCorrelationid) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        return service.getSubscriptionOperations(subscriptionId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSubscriptionOperationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSubscriptionOperationsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<OperationType>>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSubscriptionOperation(UUID subscriptionId, UUID operationId) {
        return getSubscriptionOperationWithServiceResponseAsync(subscriptionId, operationId).toBlocking().single().body();
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSubscriptionOperationAsync(UUID subscriptionId, UUID operationId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionOperationWithServiceResponseAsync(subscriptionId, operationId), serviceCallback);
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSubscriptionOperationAsync(UUID subscriptionId, UUID operationId) {
        return getSubscriptionOperationWithServiceResponseAsync(subscriptionId, operationId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSubscriptionOperationWithServiceResponseAsync(UUID subscriptionId, UUID operationId) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.getSubscriptionOperation(subscriptionId, operationId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSubscriptionOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSubscriptionOperation(UUID subscriptionId, UUID operationId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return getSubscriptionOperationWithServiceResponseAsync(subscriptionId, operationId, xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSubscriptionOperationAsync(UUID subscriptionId, UUID operationId, UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionOperationWithServiceResponseAsync(subscriptionId, operationId, xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSubscriptionOperationAsync(UUID subscriptionId, UUID operationId, UUID xMsRequestid, UUID xMsCorrelationid) {
        return getSubscriptionOperationWithServiceResponseAsync(subscriptionId, operationId, xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Get operation status.
     * Enables the publisher to track the status of the specified triggered async operation (such as Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).
     *
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getSubscriptionOperationWithServiceResponseAsync(UUID subscriptionId, UUID operationId, UUID xMsRequestid, UUID xMsCorrelationid) {
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        final String apiVersion = "2.0.0";
        final String contentType = "application/json";
        return service.getSubscriptionOperation(subscriptionId, operationId, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getSubscriptionOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getSubscriptionOperationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<OperationType>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Error object if successful.
     */
    public Error updateOperation(Object body, UUID subscriptionId, UUID operationId, String apiVersion) {
        return updateOperationWithServiceResponseAsync(body, subscriptionId, operationId, apiVersion).toBlocking().single().body();
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Error> updateOperationAsync(Object body, UUID subscriptionId, UUID operationId, String apiVersion, final ServiceCallback<Error> serviceCallback) {
        return ServiceFuture.fromResponse(updateOperationWithServiceResponseAsync(body, subscriptionId, operationId, apiVersion), serviceCallback);
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<Error> updateOperationAsync(Object body, UUID subscriptionId, UUID operationId, String apiVersion) {
        return updateOperationWithServiceResponseAsync(body, subscriptionId, operationId, apiVersion).map(new Func1<ServiceResponse<Error>, Error>() {
            @Override
            public Error call(ServiceResponse<Error> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<ServiceResponse<Error>> updateOperationWithServiceResponseAsync(Object body, UUID subscriptionId, UUID operationId, String apiVersion) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (apiVersion == null) {
            throw new IllegalArgumentException("Parameter apiVersion is required and cannot be null.");
        }
        final String contentType = "application/json";
        final UUID xMsRequestid = null;
        final UUID xMsCorrelationid = null;
        return service.updateOperation(subscriptionId, operationId, body, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Error>>>() {
                @Override
                public Observable<ServiceResponse<Error>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Error> clientResponse = updateOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Error object if successful.
     */
    public Error updateOperation(Object body, UUID subscriptionId, UUID operationId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        return updateOperationWithServiceResponseAsync(body, subscriptionId, operationId, apiVersion, xMsRequestid, xMsCorrelationid).toBlocking().single().body();
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Error> updateOperationAsync(Object body, UUID subscriptionId, UUID operationId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid, final ServiceCallback<Error> serviceCallback) {
        return ServiceFuture.fromResponse(updateOperationWithServiceResponseAsync(body, subscriptionId, operationId, apiVersion, xMsRequestid, xMsCorrelationid), serviceCallback);
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<Error> updateOperationAsync(Object body, UUID subscriptionId, UUID operationId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        return updateOperationWithServiceResponseAsync(body, subscriptionId, operationId, apiVersion, xMsRequestid, xMsCorrelationid).map(new Func1<ServiceResponse<Error>, Error>() {
            @Override
            public Error call(ServiceResponse<Error> response) {
                return response.body();
            }
        });
    }

    /**
     * Update the status of an operation.
     * Update the status of an operation to indicate success or failure with the provided values.
     *
     * @param body the Object value
     * @param subscriptionId the UUID value
     * @param operationId the UUID value
     * @param apiVersion Version of the API. Possible values include: '2018-08-31', '2018-09-15'
     * @param xMsRequestid A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in the response headers.
     * @param xMsCorrelationid A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn't provided, one will be generated and provided in the response headers.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Error object
     */
    public Observable<ServiceResponse<Error>> updateOperationWithServiceResponseAsync(Object body, UUID subscriptionId, UUID operationId, String apiVersion, UUID xMsRequestid, UUID xMsCorrelationid) {
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        if (subscriptionId == null) {
            throw new IllegalArgumentException("Parameter subscriptionId is required and cannot be null.");
        }
        if (operationId == null) {
            throw new IllegalArgumentException("Parameter operationId is required and cannot be null.");
        }
        if (apiVersion == null) {
            throw new IllegalArgumentException("Parameter apiVersion is required and cannot be null.");
        }
        final String contentType = "application/json";
        return service.updateOperation(subscriptionId, operationId, body, apiVersion, contentType, xMsRequestid, xMsCorrelationid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Error>>>() {
                @Override
                public Observable<ServiceResponse<Error>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Error> clientResponse = updateOperationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Error> updateOperationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Error, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Error>() { }.getType())
                .build(response);
    }

}
